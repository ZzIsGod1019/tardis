// This file is @generated by prost-build.
/// The request message containing the user's name.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HelloRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The response message containing the greetings
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HelloReply {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
#[allow(unused_imports)]
#[derive(Clone)]
pub struct GreeterClient {
    cli: poem_grpc::client::GrpcClient,
}
#[allow(dead_code)]
impl GreeterClient {
    #[allow(clippy::let_and_return)]
    pub fn new(config: poem_grpc::ClientConfig) -> Self {
        Self {
            cli: {
                let cli = poem_grpc::client::GrpcClient::new(config);
                cli
            },
        }
    }
    #[allow(clippy::let_and_return)]
    pub fn from_endpoint<T>(ep: T) -> Self
    where
        T: ::poem::IntoEndpoint,
        T::Endpoint: 'static,
        <T::Endpoint as ::poem::Endpoint>::Output: 'static,
    {
        Self {
            cli: {
                let cli = poem_grpc::client::GrpcClient::from_endpoint(ep);
                cli
            },
        }
    }
    pub fn with<M>(mut self, middleware: M) -> Self
    where
        M: ::poem::Middleware<
            ::std::sync::Arc<
                dyn ::poem::endpoint::DynEndpoint<Output = ::poem::Response> + 'static,
            >,
        >,
        M::Output: 'static,
    {
        self.cli = self.cli.with(middleware);
        self
    }
    /// Set the compression encoding for sending
    pub fn set_send_compressed(&mut self, encoding: poem_grpc::CompressionEncoding) {
        self.cli.set_send_compressed(encoding);
    }
    /// Set the compression encodings for accepting
    pub fn set_accept_compressed(
        &mut self,
        encodings: impl ::std::convert::Into<
            ::std::sync::Arc<[poem_grpc::CompressionEncoding]>,
        >,
    ) {
        self.cli.set_accept_compressed(encodings);
    }
    #[allow(dead_code)]
    pub async fn say_hello(
        &self,
        request: poem_grpc::Request<HelloRequest>,
    ) -> ::std::result::Result<poem_grpc::Response<HelloReply>, poem_grpc::Status> {
        let codec = <poem_grpc::codec::ProstCodec<
            _,
            _,
        > as ::std::default::Default>::default();
        self.cli.unary("/helloworld.Greeter/SayHello", codec, request).await
    }
}
#[allow(unused_imports)]
pub trait Greeter: Send + Sync + 'static {
    fn say_hello(
        &self,
        request: poem_grpc::Request<HelloRequest>,
    ) -> impl ::std::future::Future<
        Output = ::std::result::Result<
            poem_grpc::Response<HelloReply>,
            poem_grpc::Status,
        >,
    > + Send;
}
#[allow(unused_imports)]
pub struct GreeterServer<T> {
    inner: ::std::sync::Arc<T>,
    send_compressd: ::std::option::Option<poem_grpc::CompressionEncoding>,
    accept_compressed: ::std::sync::Arc<[poem_grpc::CompressionEncoding]>,
}
impl<T> ::std::clone::Clone for GreeterServer<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
            send_compressd: self.send_compressd,
            accept_compressed: self.accept_compressed.clone(),
        }
    }
}
impl<T: Greeter> poem_grpc::Service for GreeterServer<T> {
    const NAME: &'static str = "helloworld.Greeter";
}
#[allow(dead_code)]
impl<T> GreeterServer<T> {
    /// Create a new GRPC server
    pub fn new(service: T) -> Self {
        Self {
            inner: ::std::sync::Arc::new(service),
            send_compressd: ::std::option::Option::None,
            accept_compressed: ::std::sync::Arc::new([]),
        }
    }
    /// Set the compression encoding for sending
    pub fn send_compressed(self, encoding: poem_grpc::CompressionEncoding) -> Self {
        Self {
            send_compressd: Some(encoding),
            ..self
        }
    }
    /// Set the compression encodings for accepting
    pub fn accept_compressed(
        self,
        encodings: impl ::std::convert::Into<
            ::std::sync::Arc<[poem_grpc::CompressionEncoding]>,
        >,
    ) -> Self {
        Self {
            accept_compressed: encodings.into(),
            ..self
        }
    }
}
impl<T: Greeter> ::poem::IntoEndpoint for GreeterServer<T> {
    type Endpoint = ::poem::endpoint::BoxEndpoint<'static, ::poem::Response>;
    #[allow(clippy::redundant_clone)]
    #[allow(clippy::let_and_return)]
    fn into_endpoint(self) -> Self::Endpoint {
        use ::poem::endpoint::EndpointExt;
        let mut route = ::poem::Route::new();
        #[allow(non_camel_case_types)]
        struct Greetersay_helloService<T>(::std::sync::Arc<T>);
        impl<T: Greeter> poem_grpc::service::UnaryService<HelloRequest>
        for Greetersay_helloService<T> {
            type Response = HelloReply;
            async fn call(
                &self,
                request: poem_grpc::Request<HelloRequest>,
            ) -> Result<poem_grpc::Response<Self::Response>, poem_grpc::Status> {
                self.0.say_hello(request).await
            }
        }
        route = route
            .at(
                "/SayHello",
                ::poem::endpoint::make({
                    let server = self.clone();
                    move |req| {
                        let server = server.clone();
                        async move {
                            let codec = <poem_grpc::codec::ProstCodec<
                                _,
                                _,
                            > as ::std::default::Default>::default();
                            poem_grpc::server::GrpcServer::new(
                                    codec,
                                    server.send_compressd,
                                    &server.accept_compressed,
                                )
                                .unary(Greetersay_helloService(server.inner.clone()), req)
                                .await
                        }
                    }
                }),
            );
        let ep = route
            .before(|req| async move {
                if req.version() != ::poem::http::Version::HTTP_2 {
                    return Err(
                        ::poem::Error::from_status(
                            ::poem::http::StatusCode::HTTP_VERSION_NOT_SUPPORTED,
                        ),
                    );
                }
                Ok(req)
            });
        ep.boxed()
    }
}
